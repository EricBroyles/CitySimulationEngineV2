Example Use:
sim = Simulation.create(...)
sim.populate(...)
sim.set_destinations(...)
sim.set_nav_opts(...)
sim.set_paths(...)
user input -> if not sim.is_done():
    sim.step()



class Simulation
    private ig_run_sec: int
    private ig_sec_per_step: int
    private step: int
    private num_steps: int
    private world: World
    private agents: Agents

    public create(tt,tm,dir,mph,ig_runtime,ig_sec_per_step) -> Simulation:
        ig_runtime
        ig_sec_per_step
        step = 0
        num_steps = ig_run_sec / ig_sec_per_step
        world = World.create(tt,tm,dir,mph)
    public populate(num_humans,car_ownership_rate) -> void:
        agents = Agents.populate(num_humans,car_ownership_rate)
    public set_destinations() -> void:
        agents.set_destinations()
    public set_navseqs() -> void:
        agents.set_navseqs()
    public set_paths() -> void:
        #FINISH

    public is_done() -> bool:
        return step >= num_steps
    public step() -> void:
        ## FINISH

class World (GLOBAL)
    public enum TT: {NONE, ROAD, WALKWAY, CROSSWALK, PARKING, BUILDING, BARRIER, MAX}
    public enum TM: {NONE, JUNCTION_STOP, JUNCTION1, JUNCTION2, JUNCTION3, LANE_DIVIDER, MAX}
    public INVALID_CELL: Vector2i = Vector2i(-1,-1)
    #id = group_id
    private tt: Image
    private tm: Image
    private dir: Image
    private mph: Image
    private walk_cm: 2D matrix
    private drive_cm: 2D matrix
    private parking: Parking
    private avg_walk_speed: [Vector2i(walk_cm_id, avg_speed), ...]
    private avg_drive_speed: [Vector2i(drive_cm_id, avg_speed), ...]

    public create(tt,tm,dir,mph) -> World:
        tt,tm,dir,mph
        set_walk_connectivity_matrix
        set_drive_connectivity_matrix
        set_parking
    public shape() -> Vector2i
    public in_bounds(cell: Vector2i) -> bool:
    public get_lower_resolution_cell(world_coord: Vector2i, resolution: int) -> Vector2i
        # ex: (1,1), 16 -> (0,0) # ex: (5,3), 4  -> (1,0)
    public set_walk_connectivity_matrix() -> void:
    public set_drive_connectivity_matrix() -> void:
    public set_parking() -> void
    public get_tt(c,r) -> int:
    public get_tm(c,r) -> int:
    public get_dir(c,r) -> {n: T/F, s: T/F, ...}:
    public get_speed(c,r) -> int:
    public get_rand_building_cell() -> Vector2i:
    public get_rand_parking_cell() -> Vector2i:
    static public get_cm_id(cm, cell1, cell2) -> int:
        # -1 if not connected  
        group_id1 = cm[cell1.x][cell1.y]
        group_id2 = cm[cell2.y][cell2.y]
        if group_id1 != group_id2 -> -1
        return group_id1
    #public can_walk(from_cell, to_cell) -> bool:
        return World.is_connected(walk_cm, from_cell, to_cell)
    #public can_drive(from_cell, to_cell) -> bool:
        return World.is_connected(drive_cm, from_cell, to_cell)
    #public get_walk_eta(from_cell, to_cell) -> float:
        #Euclidean distance CONTINUE FROM HERE
    #public get_drive_eta(from_cell, to_cell) -> float:
        # idk yet

    static public distance(from, to):
    public get_avg_walk_speed(id):
    public get_avg_drive_speed(id):



class Parking:
    private available16x16: 2D matrix of int
    private available4x4: 2D matrix of int
    private reservations: unordered map{Vector2i: Agent}

    public create() -> Parking:
        give available16x16 and 4x4 the right size
        for c,r in World.shape:
            cell = Vector2i(c,r)
            if World.get_tt(cell) is not World.TT.PARKING: continue
            cell16x16 = get_lower_resolution_cell(cell, 16)
            cell4x4   = get_lower_resolution_cell(cell, 4)
            available16x16[cell16x16] += 1
            available4x4[cell4x4] += 1
            reservations[cell] = Agent.create_empty()
    public get_reasonable_open_spot(cell: Vector2i) -> Vector2i:
        # Vector2i(-1,-1) if no available
        # find "closest" 16x16 cell with parking available
        # find "closest" 4x4   cell with parking available
        # find "closest" 1x1   cell with parking available
    private closest16x16(cell) -> Vector2i:
        cell16x16 = get_lower_resolution_cell(cell, 16)
        # original cell16x16, current cell16x16, n

    private static spiral_search(available_matrix, cell, max_search_len) -> Vector2i
        # World.INVALID_CELL if invalid

        # search the matrix starting at the cell looking for a int > 0 return the cell Vector2i




        # do a spiral search, must check the bounds







class Agents:
    private humans: Array[Humans]
    private personal_vehicles: Array[PersonalVehicle]

    public populate(num_humans, car_ownership_rate) -> Agents:
        for num_humans:
            human_cell = World.get_rand_building_cell
            human = Human.create(human_cell)
            if car_ownership_rate contraint is met: 
                pv_cell = World.get_rand_parking_cell
                pv = PersonalVehicle.create(pv_cell)
                human.set_personal_vehicle(pv)
                pv.set_human_owner(human)
            add to arrays

    public set_destinations() -> void:
        for all humans:
            human.set_destination(World.get_rand_building_cell)
    public set_navseqs() -> void:
        for all humans:
            human.set_navseq()

class Agent:
    private cell: Vector2
    private path: Path

    public create_empty() -> Empty:
        return Empty.create()
    public create(cell: Vector2i) -> Agent
    public step() -> void:
        pass

class Empty(Agent):
    public create() -> Empty:
        return Empty.new()

class Human(Agent):
    enum NAVSEQ {NONE, WALK, PERSONAL_VEHICLE}
    private destination_cell: Vector2i
    private personal_vehicle: PersonalVehicle
    private nav_seq: int

    public set_personal_vehicle(personal_vehicle) -> void:
    public set_destination(cell: Vector2i) -> void:
    public set_navseq() -> void:
        # if no destination -> NONE
        # if destination is current cell -> NONE
        # walk_eta = 
        ## CONTINUE
    static public get_eta(from, to) -> int
        # -1 if invalid
        group_id = World.get_cm_id(World.walk_cm, from, to)
        if group_id == -1 -> -1
        dist = World.distance(from, to)
        eta = World.get_avg_walk_speed(group_id) * dist -> eta

class PersonalVehicle(Agent):
    private reserved_parking_cell
    private human_owner: Human

    public set_human_owner(human) -> void:
    public set_reserved_parking(cell: Vector2i) -> void:
    static public get_eta(from, to) -> int
        # -1 if invalid
        group_id = World.get_cm_id(World.drive_cm, from, to)
        if group_id == -1 -> -1
        dist = World.distance(from, to)
        eta = World.get_avg_walk_speed(group_id) * dist -> eta







Agents
* Cell: position they are located
* all ocupy only one cell
* HUman: may own a car
* Car: may have a owner
* path: start, end, body (what gets a path)
* Car does not know its end destination until the person gets to it??? its end destination is a reserved_parking space, th
* state: navigating. none. loiter
* when creating agents: just give them their starting position, path information comes latter
* 

Human:
* has a destination (end cell)

PersonalVehicle
* has a parking space (end cell)
     

    



















